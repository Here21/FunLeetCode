# 22. Generate Parentheses

Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

```js
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

## 解法

使用**Backtracking**来解题，思路如下：
从`"("`开始回溯，然后每次回溯最开始需要先检查是否满足长度。需要引入两个变量来记录`"("`与`")`符号的数量，判断条件是 `n > open, open > close`。
先判断`n > open`添加左括号`"("`，然后右括号要和左括号成对。

可以加一个变量，打到控制台中看回溯的过程，加深backtracking的逻辑理解。
```js
// open   close     count      str
// 0 '---' 0 '      ' 0 '---' ''
//                                        if(open < max) backtrack(str + '(', open + 1, close, max, result) 开始的回溯
// 1 '---' 0 '=     ' 1 '---' '('
// 2 '---' 0 '==    ' 2 '---' '(('
// 3 '---' 0 '===   ' 3 '---' '((('
// 3 '---' 1 '===-  ' 4 '---' '((()'
// 3 '---' 2 '===-- ' 5 '---' '((())'
// 3 '---' 3 '===---' 6 '---' '((()))'
// 2 '---' 1 '==-   ' 3 '---' '(()'
// 3 '---' 1 '==-=  ' 4 '---' '(()('
// 3 '---' 2 '==-=- ' 5 '---' '(()()'
// 3 '---' 3 '==-=-=' 6 '---' '(()())'
// 2 '---' 2 '==--  ' 4 '---' '(())'
// 3 '---' 2 '==--= ' 5 '---' '(())('
// 3 '---' 3 '==--=-' 6 '---' '(())()'

//                                         if(close < open) backtrack(str + ')', open, close + 1, max, result) 开始的回溯
// 1 '---' 1 '=-    ' 2 '---' '()'
// 2 '---' 1 '======' 3 '---' '()('
// 3 '---' 1 '======' 4 '---' '()(('
// 3 '---' 2 '======' 5 '---' '()(()'
// 3 '---' 3 '======' 6 '---' '()(())'
// 2 '---' 2 '======' 4 '---' '()()'
// 3 '---' 2 '======' 5 '---' '()()('
// 3 '---' 3 '======' 6 '---' '()()()'
// [ '((()))', '(()())', '(())()', '()(())', '()()()' ]
```